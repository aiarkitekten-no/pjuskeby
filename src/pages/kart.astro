---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout title="Map of Pjuskeby">
  <div class="map-container adventure-map-container">
    <div class="map-header">
      <h1>üó∫Ô∏è Map of Pjuskeby</h1>
      <p>Explore all places, streets, people, businesses, events and rumors in our small, absurd world</p>
    </div>

    <div class="map-controls">
      <button class="control-btn active" data-layer="all">üåç All</button>
      <button class="control-btn" data-layer="places">üìç Places</button>
      <button class="control-btn" data-layer="streets">üõ£Ô∏è Streets</button>
      <button class="control-btn" data-layer="people">üë• People</button>
      <button class="control-btn" data-layer="businesses">üè¢ Businesses</button>
      <button class="control-btn" data-layer="events">üéâ Events</button>
      <button class="control-btn" data-layer="rumors">üëÅÔ∏è Rumors</button>
    </div>

    <div id="map">
    </div>

    <div class="map-legend">
      <h3>Legend</h3>
      <div class="legend-item"><span class="legend-marker place"></span> Places</div>
      <div class="legend-item"><span class="legend-marker person"></span> People</div>
      <div class="legend-item"><span class="legend-marker business"></span> Businesses</div>
      <div class="legend-item"><span class="legend-marker event"></span> Events</div>
      <div class="legend-item"><span class="legend-marker rumor"></span> Rumors</div>
      <div class="legend-item"><span class="legend-line"></span> Streets</div>
      <div class="legend-item"><span class="legend-cluster"></span> Clustered (click to zoom)</div>
    </div>
  </div>

  <!-- Today's featured moved below map -->
  <div class="todays-featured-section">
    <div class="todays-featured-header">
      <h2>üì∞ Today's Featured in Pjuskeby</h2>
      <p class="featured-subtitle">Places, people and stories mentioned in today's tales</p>
    </div>
    <div id="featured-entities" class="featured-grid">
      <div class="loading-card">
        <div class="loading-spinner"></div>
        <p>Loading today's featured...</p>
      </div>
    </div>
  </div>
</BaseLayout>

<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@4.5.0/dist/maplibre-gl.css">

<style>
  .map-container {
    max-width: 100%;
    margin: 0 auto;
  }

  .map-header {
    text-align: center;
    padding: 2rem 1rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 12px 12px 0 0;
    margin-bottom: 0;
  }

  .map-header h1 {
    font-size: 2.5rem;
    margin: 0 0 0.5rem 0;
    font-weight: 800;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
  }

  .map-header p {
    font-size: 1.1rem;
    margin: 0;
    opacity: 0.95;
  }

  .map-controls {
    display: flex;
    gap: 0.5rem;
    padding: 1rem;
    background: white;
    border-bottom: 2px solid #e2e8f0;
    flex-wrap: wrap;
  }

  .control-btn {
    padding: 0.75rem 1.5rem;
    border: 2px solid #e2e8f0;
    background: white;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 600;
    transition: all 0.3s ease;
    color: #475569;
  }

  .control-btn:hover {
    background: #f8fafc;
    border-color: #cbd5e1;
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }

  .control-btn.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-color: #667eea;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
  }

  #map {
    width: 100%;
    height: 600px;
    background: #4FC3F7;
    border-radius: 0 0 12px 12px;
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.1);
    position: relative;
  }

  .adventure-map-notice {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(79, 195, 247, 0.9);
    padding: 1rem 1.5rem;
    border-radius: 8px;
    text-align: left;
    max-width: 300px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 1000;
    font-family: 'Comic Sans MS', cursive, sans-serif;
    color: white;
  }

  .adventure-map-notice h3 {
    margin: 0 0 0.5rem 0;
    color: white;
    font-size: 1.2rem;
  }

  .adventure-map-notice p {
    margin: 0;
    color: rgba(255,255,255,0.9);
    font-size: 0.9rem;
  }

    .map-legend, .todays-featured {
    position: absolute;
    left: 20px;
    background: rgba(255, 255, 255, 0.95);
    padding: 1rem;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    backdrop-filter: blur(10px);
    min-width: 200px;
    z-index: 1000;
  }

  .map-legend {
    bottom: 20px;
  }

  /* New section for today's featured below the map */
  .todays-featured-section {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    margin: 2rem 0;
    padding: 0;
    border-radius: 16px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.15);
    overflow: hidden;
    position: relative;
  }

  .todays-featured-section::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="white" opacity="0.1"/><circle cx="80" cy="40" r="1" fill="white" opacity="0.15"/><circle cx="40" cy="80" r="1.5" fill="white" opacity="0.1"/></svg>');
    pointer-events: none;
  }

  .todays-featured-header {
    background: rgba(255,255,255,0.95);
    backdrop-filter: blur(10px);
    padding: 2rem;
    text-align: center;
    border-bottom: 1px solid rgba(255,255,255,0.2);
  }

  .todays-featured-header h2 {
    margin: 0 0 0.5rem 0;
    font-size: 2rem;
    font-weight: 800;
    color: #1e293b;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }

  .featured-subtitle {
    margin: 0;
    color: #64748b;
    font-size: 1.1rem;
    font-weight: 500;
  }

  .featured-grid {
    padding: 2rem;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 1.5rem;
    background: rgba(255,255,255,0.05);
  }

  .story-card {
    background: rgba(255,255,255,0.95);
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 8px 25px rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
  }

  .story-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 35px rgba(0,0,0,0.15);
  }

  .story-title {
    font-size: 1.2rem;
    font-weight: 700;
    color: #1e293b;
    margin: 0 0 1rem 0;
    line-height: 1.4;
  }

  .story-entities {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .entity-group {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
  }

  .entity-label {
    font-size: 0.85rem;
    font-weight: 600;
    color: #64748b;
    min-width: 70px;
  }

  .entity-link {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.75rem;
    background: #f1f5f9;
    color: #475569;
    text-decoration: none;
    border-radius: 20px;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
    border: 1px solid transparent;
  }

  .entity-link:hover {
    background: #e2e8f0;
    color: #1e293b;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  .entity-link.person {
    background: #dbeafe;
    color: #1d4ed8;
  }
  
  .entity-link.person:hover {
    background: #bfdbfe;
    color: #1e40af;
  }

  .entity-link.place {
    background: #fecaca;
    color: #dc2626;
  }
  
  .entity-link.place:hover {
    background: #fca5a5;
    color: #b91c1c;
  }

  .entity-link.business {
    background: #d1fae5;
    color: #059669;
  }
  
  .entity-link.business:hover {
    background: #a7f3d0;
    color: #047857;
  }

  .map-highlight-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    border-radius: 25px;
    font-weight: 600;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 1rem;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
  }

  .map-highlight-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
  }

  .loading-card {
    background: rgba(255,255,255,0.95);
    border-radius: 12px;
    padding: 2rem;
    text-align: center;
    grid-column: 1 / -1;
  }

  .loading-spinner {
    width: 40px;
    height: 40px;
    border: 3px solid #e2e8f0;
    border-top: 3px solid #667eea;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 1rem;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .map-legend h3 {
    margin: 0 0 0.75rem 0;
    font-size: 1rem;
    font-weight: 700;
    color: #1e293b;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0.5rem 0;
    font-size: 0.9rem;
    color: #475569;
  }

  .legend-marker {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }

  .legend-marker.place {
    background: #ef4444;
  }

  .legend-marker.person {
    background: #3b82f6;
  }

  .legend-marker.business {
    background: #22c55e;
  }

  .legend-marker.event {
    background: #8b5cf6;
  }

  .legend-marker.rumor {
    background: #f59e0b;
  }

  .legend-line {
    width: 24px;
    height: 3px;
    background: #f59e0b;
    border-radius: 2px;
  }

  .legend-cluster {
    width: 24px;
    height: 24px;
    background: #6366f1;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 0.8rem;
    font-weight: bold;
  }

  .legend-cluster::after {
    content: '5+';
  }

  .featured-entity {
    padding: 0.5rem;
    margin: 0.25rem 0;
    background: rgba(59, 130, 246, 0.1);
    border-radius: 8px;
    border-left: 3px solid #3b82f6;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .featured-entity:hover {
    background: rgba(59, 130, 246, 0.2);
    transform: translateX(2px);
  }

  .featured-entity-name {
    font-weight: 600;
    color: #1e293b;
    font-size: 0.9rem;
  }

  .featured-entity-type {
    font-size: 0.75rem;
    color: #64748b;
    text-transform: uppercase;
  }

  .featured-entity-story {
    font-size: 0.8rem;
    color: #475569;
    margin-top: 0.25rem;
  }

  .loading {
    text-align: center;
    color: #64748b;
    font-style: italic;
  }

  .maplibregl-popup-content {
    padding: 1rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    max-width: 300px;
  }

  .maplibregl-popup-content h3 {
    margin: 0 0 0.5rem 0;
    color: #1e293b;
    font-size: 1.1rem;
  }

  .maplibregl-popup-content p {
    margin: 0.25rem 0;
    color: #475569;
    font-size: 0.9rem;
  }

  .maplibregl-popup-content a {
    display: inline-block;
    margin-top: 0.5rem;
    color: #3b82f6;
    text-decoration: none;
    font-weight: 600;
  }

  .maplibregl-popup-content a:hover {
    text-decoration: underline;
  }

  @media (max-width: 768px) {
    .map-header h1 {
      font-size: 1.8rem;
    }

    .map-controls {
      justify-content: center;
    }

    .control-btn {
      flex: 1 1 auto;
      min-width: 100px;
    }

    #map {
      height: 500px;
    }

    .map-legend {
      position: static;
      margin: 1rem;
      max-width: 100%;
    }

    .todays-featured-header h2 {
      font-size: 1.5rem;
    }

    .featured-subtitle {
      font-size: 1rem;
    }

    .featured-grid {
      grid-template-columns: 1fr;
      padding: 1rem;
      gap: 1rem;
    }

    .story-card {
      padding: 1rem;
    }

    .entity-group {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
    }

    .entity-label {
      min-width: auto;
      font-weight: 700;
    }

    .map-highlight-btn {
      width: 100%;
      justify-content: center;
    }
  }
</style>

<script is:inline src="https://unpkg.com/maplibre-gl@4.5.0/dist/maplibre-gl.js"></script>

<script is:inline>
  // Wait for MapLibre to load
  window.addEventListener('load', function() {
    console.log('üó∫Ô∏è Starting Phase 10 Map Integration...');
    console.log('üéØ Expected adventure tile: /map-tiles/city-overview/13/4338/2404.png');
    
    // Initialize Pjuskeby Adventure Map with error handling
    let map;
    try {
      map = new maplibregl.Map({
        container: 'map',
      style: {
        version: 8,
        name: "Pjuskeby Adventure Map",
        metadata: {
          "pjuskeby:type": "adventure-cartoon",
          "pjuskeby:generated": "2025-10-21T07:42:59.948Z"
        },
        glyphs: "https://fonts.openmaptiles.org/{fontstack}/{range}.pbf",
        sources: {
          'adventure-osm': {
            type: 'raster',
            tiles: [
              'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            tileSize: 256,
            attribution: '¬© Adventure Style Map - Based on OpenStreetMap'
          }
        },
        layers: [
          {
            id: 'adventure-background',
            type: 'background',
            paint: {
              'background-color': '#4FC3F7'
            }
          },
          {
            id: 'adventure-map-layer',
            type: 'raster',
            source: 'adventure-osm',
            minzoom: 0,
            maxzoom: 22,
            paint: {
              'raster-opacity': 1.0,
              'raster-brightness-max': 0.8,
              'raster-brightness-min': 0.2,
              'raster-hue-rotate': 25
            }
          },
        ]
      },
        center: [10.713027, 59.449172], // Correct Pjuskeby coordinates
        zoom: 13,
        pitch: 0,
        bearing: 0
      });

      // Add navigation controls
      map.addControl(new maplibregl.NavigationControl(), 'top-left');
      map.addControl(new maplibregl.FullscreenControl(), 'top-left');
      
      console.log('‚úÖ Map initialized successfully');
      
    } catch (mapError) {
      console.error('‚ùå Map initialization error:', mapError);
      document.getElementById('map').innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 600px; background: #f1f5f9; color: #64748b; font-size: 1.1rem;"><div>üòî Could not load the map. Please refresh the page.</div></div>';
      return;
    }

    // Track current active layers
    let activeLayers = new Set(['all']);

    // Load GeoJSON data and add to map
    map.on('load', async () => {
      try {
        console.log('üì° Loading GeoJSON data from content/data/geo/...');
        
        // Try new location first (Phase 10 requirement)
        const loadPromises = [
          fetch('/content/data/geo/places.geojson').then(r => r.json()).catch(() => null),
          fetch('/content/data/geo/streets.geojson').then(r => r.json()).catch(() => null),
          fetch('/content/data/geo/people.geojson').then(r => r.json()).catch(() => null),
          fetch('/content/data/geo/businesses.geojson').then(r => r.json()).catch(() => null),
          fetch('/content/data/geo/events.geojson').then(r => r.json()).catch(() => null),
          fetch('/content/data/geo/rumors.geojson').then(r => r.json()).catch(() => null)
        ];

        let [places, streets, people, businesses, events, rumors] = await Promise.all(loadPromises);

        // Fallback to original location if needed
        if (!places || !streets || !people || !businesses) {
          console.log('‚ö†Ô∏è Falling back to /geojson/ location...');
          [places, streets, people, businesses, events, rumors] = await Promise.all([
            fetch('/geojson/places.geojson').then(r => r.json()),
            fetch('/geojson/streets.geojson').then(r => r.json()),
            fetch('/geojson/people.geojson').then(r => r.json()),
            fetch('/geojson/businesses.geojson').then(r => r.json()),
            fetch('/geojson/events.geojson').then(r => r.json()).catch(() => ({ type: 'FeatureCollection', features: [] })),
            fetch('/geojson/rumors.geojson').then(r => r.json()).catch(() => ({ type: 'FeatureCollection', features: [] }))
          ]);
        }

        // Create empty collections if events/rumors couldn't be loaded
        if (!events) events = { type: 'FeatureCollection', features: [] };
        if (!rumors) rumors = { type: 'FeatureCollection', features: [] };

        console.log('‚úÖ Data loaded:', {
          places: places.features.length,
          people: people.features.length,
          businesses: businesses.features.length,
          events: events.features.length,
          rumors: rumors.features.length,
          streets: streets.features.length
        });

        // Add sources with clustering enabled for point data (>50 features requirement)
        const clusterConfig = {
          cluster: true,
          clusterMaxZoom: 14,
          clusterRadius: 50
        };

        map.addSource('places', { type: 'geojson', data: places, ...clusterConfig });
        map.addSource('people', { type: 'geojson', data: people, ...clusterConfig });
        map.addSource('businesses', { type: 'geojson', data: businesses, ...clusterConfig });
        map.addSource('events', { type: 'geojson', data: events, ...clusterConfig });
        map.addSource('rumors', { type: 'geojson', data: rumors, ...clusterConfig });
        map.addSource('streets', { type: 'geojson', data: streets }); // No clustering for lines

        console.log('üéØ Clustering enabled for all point layers (>50 features requirement)');

        // Add street lines layer
        map.addLayer({
          id: 'streets-layer',
          type: 'line',
          source: 'streets',
          paint: {
            'line-color': '#f59e0b',
            'line-width': 3,
            'line-opacity': 0.8
          }
        });

        // Helper function to create cluster layers
        function addClusterLayers(sourceId, color, icon) {
          // Cluster circles
          map.addLayer({
            id: `${sourceId}-clusters`,
            type: 'circle',
            source: sourceId,
            filter: ['has', 'point_count'],
            paint: {
              'circle-color': [
                'step',
                ['get', 'point_count'],
                color,
                10, color.replace(')', ', 0.8)').replace('rgb', 'rgba'),
                30, color.replace(')', ', 0.6)').replace('rgb', 'rgba')
              ],
              'circle-radius': [
                'step',
                ['get', 'point_count'],
                15, 10, 20, 30, 25
              ],
              'circle-stroke-width': 2,
              'circle-stroke-color': '#ffffff'
            }
          });

          // Cluster count labels removed to avoid glyphs dependency

          // Individual points
          map.addLayer({
            id: `${sourceId}-layer`,
            type: 'circle',
            source: sourceId,
            filter: ['!', ['has', 'point_count']],
            paint: {
              'circle-radius': icon === 'üìç' ? 8 : 7,
              'circle-color': color,
              'circle-stroke-width': 2,
              'circle-stroke-color': '#ffffff'
            }
          });
        }

        // Add all cluster layers
        addClusterLayers('places', '#ef4444', 'üìç');
        addClusterLayers('people', '#3b82f6', 'üë§');
        addClusterLayers('businesses', '#22c55e', 'üè¢');
        addClusterLayers('events', '#8b5cf6', 'üéâ');
        
        // Rumors with dynamic category colors
        map.addLayer({
          id: 'rumors-clusters',
          type: 'circle',
          source: 'rumors',
          filter: ['has', 'point_count'],
          paint: {
            'circle-color': '#f59e0b',
            'circle-radius': [
              'step',
              ['get', 'point_count'],
              15, 10, 20, 30, 25
            ],
            'circle-stroke-width': 2,
            'circle-stroke-color': '#ffffff'
          }
        });

        map.addLayer({
          id: 'rumors-layer',
          type: 'circle',
          source: 'rumors',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-radius': 8,
            'circle-color': [
              'match',
              ['get', 'category'],
              'sighting', '#3b82f6',
              'scandal', '#ef4444',
              'mystery', '#8b5cf6',
              'announcement', '#f59e0b',
              'theory', '#06b6d4',
              '#f59e0b' // default
            ],
            'circle-stroke-width': 2,
            'circle-stroke-color': '#ffffff'
          }
        });

        // Enhanced popup creation with related stories (Phase 10 requirement)
        async function createEnhancedPopup(feature, lngLat) {
          const props = feature.properties;
          const entityType = props.type;
          const slug = props.slug;

          let popupHTML = '';
          
          if (entityType === 'place') {
            popupHTML = `
              <h3>üìç ${props.name}</h3>
              <p><strong>Category:</strong> ${props.category}</p>
              <p>${props.description}</p>
              <a href="/steder/${props.slug}">Read more ‚Üí</a>
            `;
          } else if (entityType === 'event') {
            const eventDate = new Date(props.date).toLocaleDateString('en-US');
            popupHTML = `
              <h3>üéâ ${props.name}</h3>
              <p><strong>Date:</strong> ${eventDate}</p>
              <p><strong>Organizer:</strong> ${props.organizer}</p>
              <p>${props.description}</p>
              <p><strong>Attendance:</strong> ${props.attendance}</p>
            `;
          } else if (entityType === 'rumor') {
            const credColor = props.credibility >= 70 ? '#10b981' : props.credibility >= 50 ? '#f59e0b' : '#ef4444';
            popupHTML = `
              <h3>${props.icon || 'ÔøΩ'} ${props.title}</h3>
              <p><strong>Category:</strong> ${props.category}</p>
              <p style="font-size: 0.9rem; color: #64748b; margin: 0.75rem 0;">${props.content}</p>
              <div style="margin: 0.75rem 0;">
                <strong>Credibility:</strong>
                <div style="background: #e2e8f0; height: 8px; border-radius: 999px; overflow: hidden; margin-top: 0.25rem;">
                  <div style="width: ${props.credibility}%; height: 100%; background: ${credColor};"></div>
                </div>
                <span style="font-size: 0.8rem; color: ${credColor}; font-weight: bold;">${props.credibility}%</span>
              </div>
              <p style="font-size: 0.85rem; color: #64748b;"><strong>Source:</strong> ${props.sourceName} (${props.sourceType})</p>
              <a href="/rykter#${props.slug}" style="color: #3b82f6;">View all rumors ‚Üí</a>
            `;
          } else if (entityType === 'person') {
            popupHTML = `
              <h3>üë§ ${props.name}</h3>
              <p><strong>Role:</strong> ${props.role}</p>
              <p>${props.description}</p>
              <a href="/personer/${props.slug}">Read more ‚Üí</a>
            `;
          } else if (entityType === 'business') {
            popupHTML = `
              <h3>üè¢ ${props.name}</h3>
              <p><strong>Type:</strong> ${props.business_type}</p>
              <p>${props.description}</p>
              <a href="/steder/${props.slug}">Read more ‚Üí</a>
            `;
          }

          // Try to fetch related stories if we have a slug (Phase 10 enhancement)
          if (slug && (entityType === 'place' || entityType === 'person')) {
            try {
              const response = await fetch(`/api/${entityType}s/${slug}`);
              if (response.ok) {
                const entity = await response.json();
                if (entity.mentioned_in && entity.mentioned_in.length > 0) {
                  popupHTML += '<h4>üìñ Related stories:</h4>';
                  entity.mentioned_in.slice(0, 3).forEach(story => {
                    popupHTML += `<div style="margin: 0.25rem 0;"><a href="/historier/${story.slug}" style="font-size: 0.8rem; color: #3b82f6;">${story.title}</a></div>`;
                  });
                }
              }
            } catch (error) {
              console.warn('Could not fetch related stories:', error);
            }
          }

          return new maplibregl.Popup()
            .setLngLat(lngLat)
            .setHTML(popupHTML)
            .addTo(map);
        }

        // Add hover effects for all layers
        const pointLayers = ['places-layer', 'people-layer', 'businesses-layer', 'events-layer', 'rumors-layer'];
        const clusterLayers = ['places-clusters', 'people-clusters', 'businesses-clusters', 'events-clusters', 'rumors-clusters'];
        
        [...pointLayers, ...clusterLayers].forEach(layer => {
          map.on('mouseenter', layer, () => {
            map.getCanvas().style.cursor = 'pointer';
          });
          map.on('mouseleave', layer, () => {
            map.getCanvas().style.cursor = '';
          });
        });

        // Add click handlers for individual features
        pointLayers.forEach(layer => {
          map.on('click', layer, async (e) => {
            await createEnhancedPopup(e.features[0], e.lngLat);
          });
        });

        // Add click handlers for clusters (zoom in when clicked)
        clusterLayers.forEach(layer => {
          map.on('click', layer, (e) => {
            const clusterId = e.features[0].properties.cluster_id;
            const source = e.features[0].source;
            
            map.getSource(source).getClusterExpansionZoom(clusterId, (err, zoom) => {
              if (err) return;
              
              map.easeTo({
                center: e.features[0].geometry.coordinates,
                zoom: zoom
              });
            });
          });
        });

        // Streets click handler
        map.on('click', 'streets-layer', async (e) => {
          const props = e.features[0].properties;
          new maplibregl.Popup()
            .setLngLat(e.lngLat)
            .setHTML(`
              <h3>üõ£Ô∏è ${props.name}</h3>
              <p>${props.description}</p>
            `)
            .addTo(map);
        });

        // Enhanced layer control with all new layers
        const buttons = document.querySelectorAll('.control-btn');
        buttons.forEach(btn => {
          btn.addEventListener('click', () => {
            const layer = btn.dataset.layer;
            buttons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            activeLayers.clear();
            activeLayers.add(layer);

            // Define all layer groups (cluster-count temporarily removed)
            const layerGroups = {
              places: ['places-layer', 'places-clusters'],
              people: ['people-layer', 'people-clusters'],
              businesses: ['businesses-layer', 'businesses-clusters'],
              events: ['events-layer', 'events-clusters'],
              rumors: ['rumors-layer', 'rumors-clusters'],
              streets: ['streets-layer']
            };

            // Hide all layers first
            Object.values(layerGroups).flat().forEach(layerId => {
              if (map.getLayer(layerId)) {
                map.setLayoutProperty(layerId, 'visibility', 'none');
              }
            });

            // Show selected layers
            if (layer === 'all') {
              Object.values(layerGroups).flat().forEach(layerId => {
                if (map.getLayer(layerId)) {
                  map.setLayoutProperty(layerId, 'visibility', 'visible');
                }
              });
            } else if (layerGroups[layer]) {
              layerGroups[layer].forEach(layerId => {
                if (map.getLayer(layerId)) {
                  map.setLayoutProperty(layerId, 'visibility', 'visible');
                }
              });
            }
          });
        });

        // Fit bounds to show all features on load
        const allFeatures = [
          ...places.features,
          ...people.features,
          ...businesses.features,
          ...events.features,
          ...rumors.features
        ];

        if (allFeatures.length > 0) {
          const bounds = new maplibregl.LngLatBounds();
          allFeatures.forEach(feature => {
            if (feature.geometry.type === 'Point') {
              bounds.extend(feature.geometry.coordinates);
            }
          });
          map.fitBounds(bounds, { padding: 50, maxZoom: 14 });
        }

        console.log('‚úÖ Phase 10 Map Integration completed successfully!');
        console.log('üéØ Features:', allFeatures.length, 'total features loaded with clustering');
        console.log('üìä Layers: 6 data types + clustering support');
        console.log('üîó Enhanced POI popovers with related stories enabled');

        // Load today's featured entities with timeout
        setTimeout(() => {
          loadTodaysFeatured();
        }, 1000);

      } catch (error) {
        console.error('‚ùå Error loading GeoJSON data:', error);
      }
    });

    // Function to load today's featured entities from stories
    async function loadTodaysFeatured() {
      console.log('üì∞ [loadTodaysFeatured] Starting...');
      // Set loading timeout
      const timeoutId = setTimeout(() => {
        console.warn('‚è±Ô∏è [loadTodaysFeatured] Timeout - taking too long');
        document.getElementById('featured-entities').innerHTML = '<div class="loading-card"><p>‚è±Ô∏è Loading took too long. Using cached data...</p></div>';
      }, 5000);
      
      try {
        console.log('üì∞ [loadTodaysFeatured] Loading todays featured entities...');
        
        // Fetch today's actual stories
        const today = new Date().toISOString().split('T')[0];
        let todaysStories = [];
        
        // Use hardcoded data for today (October 22, 2025)
        todaysStories = [
          {
            title: "Diary of Whimsy and Whatnots: The Case of the Invisible Spoons and the Suspect Hat",
            characters: ["Lola Fizzletwig", "Trixie Wobblethorpe"],
            locations: ["Boingy Beach"],
            mentions: [
              { type: 'person', name: 'Lola Fizzletwig', slug: 'lola-fizzletwig' },
              { type: 'person', name: 'Trixie Wobblethorpe', slug: 'trixie-wobblethorpe' },
              { type: 'place', name: 'Boingy Beach', slug: 'boingy-beach' }
            ]
          },
          {
            title: "The Mystery of the Creaky Corner's Cupboard",
            characters: ["Eustace Jumblebottom", "Trixie Wobblethorpe"],
            locations: ["Creaky Corner"],
            mentions: [
              { type: 'person', name: 'Eustace Jumblebottom', slug: 'eustace-jumblebottom' },
              { type: 'person', name: 'Trixie Wobblethorpe', slug: 'trixie-wobblethorpe' },
              { type: 'place', name: 'Creaky Corner', slug: 'creaky-corner' }
            ]
          },
          {
            title: "The Whisper of Lamplight and Morse Burps: A Snoreberry Tale", 
            characters: ["Clive Flumpington", "Edna Snortwig"],
            locations: ["Boingy Beach"],
            mentions: [
              { type: 'person', name: 'Clive Flumpington', slug: 'clive-flumpington' },
              { type: 'person', name: 'Edna Snortwig', slug: 'edna-snortwig' },
              { type: 'place', name: 'Boingy Beach', slug: 'boingy-beach' }
            ]
          }
        ];
        
        const featuredContainer = document.getElementById('featured-entities');
        console.log('üì∞ [loadTodaysFeatured] featuredContainer found:', !!featuredContainer);
        
        if (!todaysStories || todaysStories.length === 0) {
          console.warn('üì∞ [loadTodaysFeatured] No stories found');
          featuredContainer.innerHTML = '<p class="loading">No featured items today</p>';
          return;
        }
        
        console.log('üì∞ [loadTodaysFeatured] Processing', todaysStories.length, 'stories');
        
        // Extract entities mentioned in today's stories
        const mentionedEntities = new Map();
        
        todaysStories.forEach(story => {
          if (story.mentions) {
            story.mentions.forEach(mention => {
              const key = `${mention.type}-${mention.slug}`;
              if (!mentionedEntities.has(key)) {
                mentionedEntities.set(key, {
                  ...mention,
                  stories: [story.title]
                });
              } else {
                mentionedEntities.get(key).stories.push(story.title);
              }
            });
          }
        });
        
        // Create story cards with entities and links
        let featuredHTML = '';
        todaysStories.forEach((story, idx) => {
          const entityGroups = {
            person: [],
            place: [],
            business: []
          };
          
          // Group entities by type
          if (story.mentions) {
            story.mentions.forEach(mention => {
              if (entityGroups[mention.type]) {
                entityGroups[mention.type].push(mention);
              }
            });
          }
          
          featuredHTML += '<div class="story-card">';
          featuredHTML += '<h3 class="story-title">' + story.title.replace(/'/g, '&#39;') + '</h3>';
          featuredHTML += '<div class="story-entities">';
          
          Object.entries(entityGroups).forEach(([type, entities]) => {
            if (entities.length > 0) {
              featuredHTML += '<div class="entity-group">';
              featuredHTML += '<span class="entity-label">' + getEntityTypeLabel(type) + ':</span>';
              entities.forEach(entity => {
                featuredHTML += '<a href="' + getEntityUrl(entity.type, entity.slug) + '" class="entity-link ' + entity.type + '" onclick="event.stopPropagation()">';
                featuredHTML += getEntityIcon(entity.type) + ' ' + entity.name.replace(/'/g, '&#39;');
                featuredHTML += '</a>';
              });
              featuredHTML += '</div>';
            }
          });
          
          featuredHTML += '</div>';
          featuredHTML += '<button class="map-highlight-btn" data-story-idx="' + idx + '" onclick="highlightStoryByIndex(' + idx + ')">üéØ Show on map</button>';
          featuredHTML += '</div>';
        });
        
        // Store stories in a global variable for access by onclick handlers
        window.todaysStoriesData = todaysStories;
        
        console.log('üì∞ [loadTodaysFeatured] HTML generated, length:', featuredHTML.length);
        console.log('üì∞ [loadTodaysFeatured] Setting innerHTML...');
        
        featuredContainer.innerHTML = featuredHTML || '<div class="loading-card"><p>No stories found for today</p></div>';
        
        console.log('‚úÖ [loadTodaysFeatured] Complete!');
        
        // Clear timeout since we completed successfully
        clearTimeout(timeoutId);
        
      } catch (error) {
        clearTimeout(timeoutId);
        console.error('‚ùå [loadTodaysFeatured] Error:', error);
        console.error('‚ùå [loadTodaysFeatured] Stack:', error.stack);
        document.getElementById('featured-entities').innerHTML = '<div class="loading-card"><p>üòî Could not load today\'s featured. Please refresh the page.</p></div>';
      }
    }
    
    // Helper function to get entity type labels
    function getEntityTypeLabel(type) {
      const labels = {
        'place': 'Places',
        'person': 'People', 
        'business': 'Businesses',
        'street': 'Streets',
        'event': 'Events',
        'rumor': 'Rumors'
      };
      return labels[type] || type;
    }

    // Helper function to get entity URLs
    function getEntityUrl(type, slug) {
      const baseUrls = {
        'person': '/personer/',
        'place': '/steder/',
        'business': '/bedrifter/',
        'street': '/gater/',
        'event': '/arrangementer/',
        'rumor': '/rykter/'
      };
      return (baseUrls[type] || '/') + slug;
    }

    // Helper function to get entity icons
    function getEntityIcon(type) {
      const icons = {
        'person': 'üë§',
        'place': 'üìç',
        'business': 'üè™',
        'street': 'üõ£Ô∏è',
        'event': 'üìÖ',
        'rumor': 'üí¨'
      };
      return icons[type] || 'üìå';
    }
    
    // Function to highlight story by index
    window.highlightStoryByIndex = function(idx) {
      const story = window.todaysStoriesData[idx];
      if (story && story.mentions) {
        highlightStoryEntities(story.title, story.mentions);
      }
    };
    
    // Function to highlight story entities on map
    window.highlightStoryEntities = function(storyTitle, entities) {
      console.log('üéØ Highlighting entities for:', storyTitle);
      
      if (!entities || entities.length === 0) {
        console.warn('No entities to highlight');
        return;
      }

      // Clear existing highlights
      clearHighlights();

      // Find and highlight each entity
      const foundEntities = [];
      entities.forEach(entity => {
        const found = findEntityOnMap(entity.type, entity.slug);
        if (found) {
          foundEntities.push(found);
          highlightEntityOnMap(found.feature, found.source);
        }
      });

      // Zoom to fit all entities if any were found
      if (foundEntities.length > 0) {
        const bounds = new maplibregl.LngLatBounds();
        foundEntities.forEach(entity => {
          if (entity.feature.geometry.type === 'Point') {
            bounds.extend(entity.feature.geometry.coordinates);
          }
        });
        
        // Add some padding and zoom to bounds
        map.fitBounds(bounds, { 
          padding: { top: 50, bottom: 50, left: 50, right: 50 },
          maxZoom: 15
        });
      }
    };

    // Function to find entity on map
    function findEntityOnMap(type, slug) {
      const sourceMap = {
        'person': 'people',
        'place': 'places',
        'business': 'businesses',
        'street': 'streets'
      };
      
      const sourceName = sourceMap[type];
      if (!sourceName || !map.getSource(sourceName)) {
        return null;
      }

      const sourceData = map.getSource(sourceName)._data;
      if (sourceData && sourceData.features) {
        const feature = sourceData.features.find(f => 
          f.properties.slug === slug
        );
        
        if (feature) {
          return { feature, source: sourceName };
        }
      }
      return null;
    }

    // Function to highlight entity on map
    function highlightEntityOnMap(feature, sourceName) {
      // Add highlighting style (this is a simplified version)
      // In a full implementation, you might want to add a temporary layer
      console.log('üéØ Highlighting:', feature.properties.name, 'from', sourceName);
      
      // Create a popup for the highlighted entity
      const popup = createPopup(
        feature.geometry.coordinates, 
        feature.properties.name,
        feature.properties.type,
        feature.properties
      );
      
      // Store popup for later cleanup
      if (!window.highlightPopups) {
        window.highlightPopups = [];
      }
      window.highlightPopups.push(popup);
    }

    // Function to clear highlights
    function clearHighlights() {
      if (window.highlightPopups) {
        window.highlightPopups.forEach(popup => popup.remove());
        window.highlightPopups = [];
      }
    }

    // Function to highlight entity on map (legacy function, kept for compatibility)
    function highlightEntity(type, slug) {
      const found = findEntityOnMap(type, slug);
      if (found) {
        const { feature } = found;
        
        // Fly to entity location
        map.flyTo({
          center: feature.geometry.coordinates,
          zoom: 16,
          duration: 1500
        });
        
        // Show popup for entity
        setTimeout(() => {
          map.fire('click', {
            lngLat: feature.geometry.coordinates,
            point: map.project(feature.geometry.coordinates)
          });
        }, 1600);
      } else {
        console.warn('Entity not found on map:', type, slug);
      }
    }

    // Function to highlight story locations on map
    window.highlightStoryByIndex = function(storyIdx) {
      console.log('üéØ Highlighting story index:', storyIdx);
      
      if (!window.todaysStoriesData || !window.todaysStoriesData[storyIdx]) {
        console.warn('Story not found:', storyIdx);
        return;
      }
      
      const story = window.todaysStoriesData[storyIdx];
      console.log('üìñ Story:', story.title);
      
      // Clear previous highlights
      clearHighlights();
      
      // Collect all entity locations from the story
      const locations = [];
      
      // Check both 'mentions' and 'entities' fields for compatibility
      const entityList = story.mentions || story.entities || [];
      
      if (entityList.length > 0) {
        entityList.forEach(mention => {
          // Only highlight entities that have coordinates (places, people, businesses)
          const found = findEntityOnMap(mention.type, mention.slug);
          if (found) {
            locations.push(found);
            
            // Create simple popup for each entity
            const icon = mention.type === 'person' ? 'üë§' : mention.type === 'place' ? 'üìç' : mention.type === 'street' ? 'üõ£Ô∏è' : 'üè¢';
            const popupHTML = `<h3>${icon} ${mention.name}</h3>`;
            
            const popup = new maplibregl.Popup({
              closeButton: true,
              closeOnClick: false
            })
              .setLngLat(found.feature.geometry.coordinates)
              .setHTML(popupHTML)
              .addTo(map);
            
            if (!window.highlightPopups) {
              window.highlightPopups = [];
            }
            window.highlightPopups.push(popup);
          }
        });
      }
      
      if (locations.length === 0) {
        console.warn('No locations found for story');
        return;
      }
      
      // If single location, fly to it
      if (locations.length === 1) {
        map.flyTo({
          center: locations[0].feature.geometry.coordinates,
          zoom: 16,
          duration: 1500
        });
      } else {
        // If multiple locations, fit bounds to show all
        const bounds = new maplibregl.LngLatBounds();
        locations.forEach(loc => {
          bounds.extend(loc.feature.geometry.coordinates);
        });
        map.fitBounds(bounds, {
          padding: 100,
          maxZoom: 15,
          duration: 1500
        });
      }
    };
    
  }); // End of window.addEventListener('load')
</script>
